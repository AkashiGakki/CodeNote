# Function

## 三、理解函数

> 把 `JavaScript` 作为函数式语言来理解。

### 3.1 函数是第一类对象

> `JavaScript` 中最关键的概念是：函数是第一类对象（`first-class objects`）或者说函数是一等公民。

函数和普通的 `JavaScript` 数据类型一样，可以：

- 通过字面量创建

```js
function func () {}
console.log(typeof func)    // function
```

- 赋值给变量、数组项或其他对象的属性

```js
const func = function() {}

let arr = [];
arr.push(function () {});

arr.func = function() {}
```

- 作为函数的参数来传递

```js
const funcA = function () {
  console.log(1);
}
const funcB = function (func) {
  func();
}

funcB(funcA);   // 1
```

- 作为函数的返回值

```js
const funcC = function () {
  console.log(2);
}
const funcD = function () {
  return funcC();
}

funcD();    // 2
```

- 具有动态创建和分配的属性

```js
const func = function () {}
func.user = "akashi";
console.log(func.name);     // akashi
```

### 3.2 回调函数

> 函数作为另一个函数的参数，在执行的过程中，会在稍后的某一个合适的时间点 `再回来调用`。

```js
function useless(funcCallback) {
  return funcCallback();
}
```

一个比较器排序的例子：

```js
let arr = [0, 3, 2, 5, 7, 4, 8, 6, 1];

arr.sort((value1, value2) => {
  return value1 - value2;
});

console.log(arr);   // [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
```

`JavaScript` 引擎每次需要比较两个值的时候都会调用我们提供的回调函数。

### 3.3 函数作为对象使用

> 将函数视为对象，可以在其上添加属性，同时我们还可以做更多的事情。

- 在集合中存储函数，轻易管理相关联的函数
  - 例如，特殊情况下调用的回调函数。
- 自记忆函数
  - 记忆函数上次计算得到的值，从而提高后续调用的性能。

#### 存储函数

例如，管理事件发生后需要调用的回调函数集合。

#### 自记忆函数

- 优势
  - 函数调用时会寻找之前调用所得到的值，性能会有所提升
  - 界面和用户无感知
- 弊端
  - 任何类型的缓存都会为性能牺牲内存
  - 缓存逻辑不应该和业务逻辑混合（后续的对象访问有解决方案）
  - 难做负载测试或估计算法复杂度，因为结果依赖函数之前的输入

### 3.4 函数定义

`JavaScript` 提供了以下几种定义函数的方式：

- 函数定义和函数表达式

```js
// 函数定义
function add (x, y) {
  return x + y;
}

// 函数表达式
const add = function (x, y) {
  return x + y;
}
```

- 箭头函数（lambda函数）

```js
// 箭头函数
const add = (x, y) => x + y;
```

- 函数构造函数

```js
// 构造函数
const add = new Function('x', 'y', 'return x + y');
```

- 函数生成器

```js
let generate = function* (num) {
  for (let i = 0; i < num; i++) {
    num--;
    yield num;
  }
}

let res = generate(3);

console.log(res.next());    // { value: 2, done: false }
console.log(res.next());    // { value: 1, done: false }
console.log(res.next());    // { value: undefined, done: true }
```

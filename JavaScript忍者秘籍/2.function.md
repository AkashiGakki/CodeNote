# Function

## 三、理解函数

> 把 `JavaScript` 作为函数式语言来理解。

### 3.1 函数是第一类对象

> `JavaScript` 中最关键的概念是：函数是第一类对象（`first-class objects`）或者说函数是一等公民。

函数和普通的 `JavaScript` 数据类型一样，可以：

- 通过字面量创建

```js
function func() {}
console.log(typeof func); // function
```

- 赋值给变量、数组项或其他对象的属性

```js
const func = function () {};

let arr = [];
arr.push(function () {});

arr.func = function () {};
```

- 作为函数的参数来传递

```js
const funcA = function () {
  console.log(1);
};
const funcB = function (func) {
  func();
};

funcB(funcA); // 1
```

- 作为函数的返回值

```js
const funcC = function () {
  console.log(2);
};
const funcD = function () {
  return funcC();
};

funcD(); // 2
```

- 具有动态创建和分配的属性

```js
const func = function () {};
func.user = "akashi";
console.log(func.name); // akashi
```

### 3.2 回调函数

> 函数作为另一个函数的参数，在执行的过程中，会在稍后的某一个合适的时间点 `再回来调用`。

```js
function useless(funcCallback) {
  return funcCallback();
}
```

一个比较器排序的例子：

```js
let arr = [0, 3, 2, 5, 7, 4, 8, 6, 1];

arr.sort((value1, value2) => {
  return value1 - value2;
});

console.log(arr); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
```

`JavaScript` 引擎每次需要比较两个值的时候都会调用我们提供的回调函数。

### 3.3 函数作为对象使用

> 将函数视为对象，可以在其上添加属性，同时我们还可以做更多的事情。

- 在集合中存储函数，轻易管理相关联的函数
  - 例如，特殊情况下调用的回调函数。
- 自记忆函数
  - 记忆函数上次计算得到的值，从而提高后续调用的性能。

#### 存储函数

例如，管理事件发生后需要调用的回调函数集合。

#### 自记忆函数

- 优势
  - 函数调用时会寻找之前调用所得到的值，性能会有所提升
  - 界面和用户无感知
- 弊端
  - 任何类型的缓存都会为性能牺牲内存
  - 缓存逻辑不应该和业务逻辑混合（后续的对象访问有解决方案）
  - 难做负载测试或估计算法复杂度，因为结果依赖函数之前的输入

### 3.4 函数定义

`JavaScript` 提供了以下几种定义函数的方式：

- 函数声明和函数表达式

```js
// 函数声明
function add(x, y) {
  return x + y;
}

// 函数表达式
const add = function (x, y) {
  return x + y;
};
```

- 箭头函数（lambda 函数）

```js
// 箭头函数
const add = (x, y) => x + y;
```

- 函数构造函数

```js
// 构造函数
const add = new Function("x", "y", "return x + y");
```

- 函数生成器

```js
let generate = function* (num) {
  for (let i = 0; i < num; i++) {
    num--;
    yield num;
  }
};

let res = generate(3);

console.log(res.next()); // { value: 2, done: false }
console.log(res.next()); // { value: 1, done: false }
console.log(res.next()); // { value: undefined, done: true }
```

- 立即函数

> 创建一个函数，然后立即调用这个新创建的函数，这种函数叫做立即调用函数表达式（`IIFE`）或者简写为立即函数。

```js
(function (argument) {
  console.log(argument); // 3
})(3);
```

- 箭头函数

> 箭头函数是函数表达式的简化版。

```js
const sum = (param1, param2) => param1 + param2;

const add = (a, b) => {
  return a + b;
};
```

### 3.5 函数的实参和形参

- 形参是我们定义函数时所列举的变量
- 实参是我们调用函数时所传递给函数的值

实参的数量大于形参的数量时并不会抛出错误，额外的实参不会赋值给任何形参。

### 3.6 剩余参数

> 为函数的最后一个命名参数加上 `...` 前缀，这个参数就变成了剩余参数的数组，内部包含传入的剩余参数。

```js
const addMix = (first, ...params) => {
  return first + params.reduce((a, b) => a + b);
};

let res = addMix(1, 2, 3);
console.log(res);
```

### 3.6 默认参数

> 适当的使用默认参数可以有效避免空值，或作为配置函数的简单标记能够带来简洁优雅的代码。

```js
// es5
const greet = (name) => {
  let person = name || "akashi";
  console.log("Hello, " + person);
};

// es6
const greet = (name = "akashi") => {
  console.log("Hello, " + name);
};
```

## 四、函数调用

> 参数 `this` 表示被调用函数的上下文对象，而 `arguments` 参数表示函数调用过程中传递的实际参数。

### 4.1 隐式函数参数

- `arguments` 参数

> `arguments` 参数是传递给函数的所有参数合集，无论是否有明确的定义对象的形参，都可以通过 `arguments` 访问到函数的所有参数。

借此还可以实现 `JS` 并不支持的函数重载特性、接收参数可变的可变函数。

如今，通过剩余参数的使用，大部分 `arguments` 需求已经可以实现，推荐使用剩余参数的方式。

在非严格模式下，`arguments` 对象作为函数参数的别名，即当 `arguments` 类数组中的值被赋了一个新值，那么同时也会改变对应传入函数参数的值。

```js
function infiltrate(person) {
  arguments[0] = "akashi";
  console.log("arguments:", arguments[0], "person:", person); // arguments: akashi person: akashi
}

infiltrate("asuka");
```

这样将 `arguments` 作为对象的别名使用会影响代码的可读性，因此在 `JavaScript` 的严格模式中将无法使用。

实际编程中，我们应该尽量避免使用 `arguments` 作为别名。

```js
"use strict";

function infiltrate(person) {
  arguments[0] = "akashi";
  console.log("arguments", arguments[0], "person", person); // arguments: akashi person: asuka
}

infiltrate("asuka");
```

或者使用函数表达式也可以达到预期的效果：

```js
const infiltrate = (person) => {
  arguments[0] = "akashi";
  console.log("arguments", arguments[0], "person", person); // arguments akashi person asuka
};

infiltrate("asuka");
```

- `this` 参数（函数上下文）

> 当调用函数时，除了显示提供参数外，`this` 参数也会默认的传递给函数。

注意：`this` 参数的指向不仅与定义函数的方式和位置有关，同时与函数的调用方式有关。

> 参数 `this` 表示被调用函数的上下文对象，而 `arguments` 参数表示函数调用过程中传递的所有参数。

### 4.2 函数调用

函数调用的 `4` 种方式：

- 作为一个函数（`function`）被直接调用

```js
const func = () => {
  console.log('function call');
}

func();
```

在这种方式调用时，函数上下文 (`this`) 有两种情况：

(1) 非严格模式下，它将是全局上下文（`window` 对象）

(2) 严格模式下，它将是 `undefined`

- 作为一个方法（`method`）关联到一个对象上

```js
const obj = {
  func: () => {
    console.log('function call as method');
  }
}

obj.func();
```

当函数作为某个对象的方法被调用时，该对象会成为函数的上下文。

- 作为一个构造函数（`constructor`）实例化一个新对象

```js
const Func = function() {
  this.foo = () => {
    console.log('function call as constructor');
  }
}

const func = new Func();
func.foo();
```

注意：构造函数可以通过函数声明和函数表达式很容易的构造出新的对象，唯一例外的是箭头函数。

> 注意区分函数的构造器和构造函数，通过函数的构造器可以将动态创建的字符串创建为函数，
> 而构造函数是指用来创建和初始化对象实例的函数。

当调用构造函数时，即使用关键字 `new` 调用函数会触发以下几个动作：

1. 创建一个新的空对象

2. 该对象作为 `this` 参数传递给构造函数，从而成为构造函数的函数上下文

3. 新构造的对象作为 `new` 运算符的返回值

构造函数的目的是创建一个新对象，并进行初始化，然后将其作为构造函数的返回值返回。

一些命名规范：

普通函数：动词，小写字母开头；

构造函数：名词，大写字母开头。

- 通过函数的 `apply` 或 `call` 方法调用

> `JavaScript` 提供了一种调用函数的方式，可以显式的指定任何对象作为函数的上下文，即使用 `apply` 和 `call`

1. `apply` 方法调用函数需要传递两个参数：作为函数上下文的对象和一个数组作为函数调用的参数。

2. `call` 方法调用函数，以参数列表的形式进行参数传递。

```js
function func(...name) {
  console.log(...name);
}

func.apply(this, ['akashi', 'asuka', 'shiori'])
func.call(this, 'akashi', 'asuka');
```
